     Министерство общего и профессионального образования РФ
                        _________________
               Санкт-Петербургский государственный
                 электротехнический университет
      ____________________________________________________













                      Методические указания
              к лабораторным работам по дисциплине
                   "ОПЕРАЦИОННЫЕ СРЕДЫ АСОИУ"

















                           Санкт-Петербург
                                 1997

     Министерство общего и профессионального образования РФ
                        _________________
               Санкт-Петербургский государственный
                 электротехнический университет
      ____________________________________________________













                      Методические указания
              к лабораторным работам по дисциплине
                   "ОПЕРАЦИОННЫЕ СРЕДЫ АСОИУ"

















                           Санкт-Петербург
                                 1997



УДК 681.518.3:681.3.06

     Методические указания к лабораторным работам  по  дисциплине
"Операционные среды АСОИУ" / Сост.:  В.В Сидельников,  В.В. Широ-
ков; ГЭТУ. СПб., 1997. 36 с.






     Приведены общие сведения и рекомендации по выполнению  лабо-
раторных работ по дисциплине "Операционные среды АСОИУ".
     Предназначены для студентов специальности 220200  "Автомати-
зированные системы обработки информации и управления".






                           Утверждено
          редакционно-издательским советом университета
                в качестве методических указаний












                                           С    С.-Пб. ГЭТУ, 1997


                              - 3 -
                       2Лабораторная работа 1
     2ИЗУЧЕНИЕ АЛГОРИТМОВ РЕАЛИЗАЦИИ И ИСПОЛЬЗОВАНИЯ СОПРОГРАММ

      1Цель работы 0  - ознакомление с алгоритмами реализации сопрог-
рамм и способами их использования для организации  многозадачнос-
ти.

                          2Общие сведения

     Сопрограммы - это средство передачи управления из одной про-
цедуры в другую без отношения вложенности.  Выполняемой процедуре
нет необходимости возвращаться в вызвавшую ее процедуру. Традици-
онные операторы ВЫЗОВ и ВОЗВРАТ в  случае  сопрограмм  заменяются
одним оператором - ПЕРЕДАТЬ_УПРАВЛЕНИЕ. Сопрограммы обладают сле-
дующими свойствами:
     1) позволяют  имитировать параллельность с помощью явных пе-
редач управления;
     2) являются средством реализации многозадачного режима.
     Реализация сопрограмм  основана  на  выделении  собственного
стека для каждой из процедур.  Тогда оператор ПЕРЕДАТЬ_УПРАВЛЕНИЕ
по существу выполняет операцию  замены  стека  приостанавливаемой
сопрограммы на стек возобновляемой сопрограммы.
     Работа процедур в качестве сопрограмм требует  предваритель-
ной подготовки,  состоящей в выделении стека каждой из процедур и
записи в стек точки входа в процедуру.  Текущее  состояние  стека
каждой  из  сопрограмм хранится в структуре,  называемой ДЕСКРИП-
ТОР_СОПРОГРАММЫ.  Поэтому сопрограммы представляются своими деск-
рипторами.

             2Технология реализации и работы сопрограмм

     Поскольку работа со стеком требует доступа непосредственно к
регистрам SS и SP, оператор ПЕРЕДАТЬ_УПРАВЛЕНИЕ может быть реали-
зован только средствами языка ассемблера.
     Оформление ассемблерной процедуры в среде Pascal:
Procedure Name_Proc(Параметры-значения; Параметры-переменные);
Assembler; {обязательный атрибут}
Asm {обязательный атрибут}
   ...

                              - 4 -
End;
     Запись в адресуемую ячейку памяти производится оператором
                     MemW[Seg:Ofs] := ...  .

     Технология реализации сопрограмм представлена в форме описа-
ния последовательностей действий,  производимых при создании соп-
рограммы и при передаче управления от одной сопрограммы к другой.

Procedure СОЗДАТЬ_СОПРОГРАММУ;
Begin
     ВЫДЕЛИТЬ ПАМЯТЬ ПОД СТЕК;
     ВЫДЕЛИТЬ ПАМЯТЬ ПОД ДЕСКРИПТОР;
     ВЫЧИСЛИТЬ АДРЕС "ДНА" СТЕКА И  ЗАПИСАТЬ ЕГО В ДЕСКРИПТОР;
     ПО АДРЕСУ "ДНА" СТЕКА ЗАПИСАТЬ ТОЧКУ ВХОДА В ПРОЦЕДУРУ;
End;

Procedure ПЕРЕДАТЬ_УПРАВЛЕНИЕ; Assembler;
Asm
     СЧИТАТЬ АДРЕС ДЕСКРИПТОРА ПРИОСТАНАВЛИВАЕМОЙ СОПРОГРАММЫ;
     ЗАПИСАТЬ В ЭТОТ ДЕСКРИПТОР СОСТОЯНИЕ СТЕКА;
     СЧИТАТЬ АДРЕС ДЕСКРИПТОРА ВОЗОБНОВЛЯЕМОЙ СОПРОГРАММЫ;
     ВОССТАНОВИТЬ СОСТОЯНИЕ СТЕКА ИЗ ЭТОГО ДЕСКРИПТОРА;
End;

     Технология работы  сопрограмм представлена в форме "заготов-
ки" программы:
Program Cor;
Procedure СОЗДАТЬ_СОПРОГРАММУ;
Begin
     ...
End;
Procedure ПЕРЕДАТЬ_УПРАВЛЕНИЕ; Assembler;
Asm
     ...
End;
Procedure User_1;
Begin
while true do begin
     ...

                              - 5 -
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ;  {в другую сопрограмму}
end;
End;
     ...
Procedure User_N;
Begin
while true do begin
     ...
     if УСЛОВИЕ then    {завершение выполнения}
        ПЕРЕДАТЬ_УПРАВЛЕНИЕ   {в главную программу}
     else
        ПЕРЕДАТЬ_УПРАВЛЕНИЕ;  {в другую сопрограмму}
     end;
End;
Begin
     СОЗДАТЬ_СОПРОГРАММУ;  {User_1}
     ...
     СОЗДАТЬ_СОПРОГРАММУ;  {User_N}
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ;  {в одну из сопрограмм}
End.
                              2Задание

     1. Реализовать  процедуры СОЗДАТЬ_СОПРОГРАММУ и ПЕРЕДАТЬ_УП-
РАВЛЕНИЕ по их спецификациям, представленным выше.
     2. Реализовать  программу  Cor,  заменив  словесные описания
действий операторами языка Pascal.
     3. Нарисовать состояния стека сопрограммы при создании, при-
остановке и возобновлении.
     4. В разрабатываемой демонстрационной программе организовать
динамическое выделение и освобождение памяти  под  дескрипторы  и
стеки сопрограмм.
     5. Реализовать  сопрограммы,  представив их в виде объектов,
включающих следующие данные - адрес стека и значения регистров SS
и SP, а также методы создания, уничтожения и передачи управления.

      1Отчет должен содержать 0 тексты программ с комментариями и ри-
сунки, отражающие состояния стеков сопрограмм.



                              - 6 -
                       2Лабораторная работа 2
         2ИССЛЕДОВАНИЕ ПРИНЦИПОВ ДИСПЕТЧЕРИЗАЦИИ ПРОЦЕССОВ

      1Цель работы 0 - ознакомление с принципами реализации  алгорит-
мов диспетчеризации процессов в многозадачных средах.

                          2Общие сведения

     Реализация псевдопараллельного режима с помощью явного вклю-
чения  в  пользовательские процессы оператора ПЕРЕДАТЬ_УПРАВЛЕНИЕ
обладает недостатками:
     1) Пользовательские процессы включают в себя действия, кото-
рые по существу не относятся к их функциям.
     2) Интервалы процессорного времени,  предоставляемые процес-
сам, зависят от самих процессов, и есть опасность захвата процес-
сора на длительный срок одним процессом.
     Поэтому в многозадачных системах используется принудительная
передача  управления.  Моменты принудительной передачи управления
определяются прерываниями от таймера.  Такой способ передачи  уп-
равления называется диспетчеризацией.
     Работает многозадачная система с принудительной  диспетчери-
зацией следующим образом.
     Выполнение текущей сопрограммы приостанавливается прерывани-
ем от таймера. Управление передается программе-обработчику преры-
вания.  Обработчик выполняет действия по выбору следующей сопрог-
раммы и передает ей управление оператором ПЕРЕДАТЬ_УПРАВЛЕНИЕ.
     Таким образом каждой сопрограмме  выделяется  квант  времени
для выполнения.

      2Сведения из языка Паскаль, используемые при реализации
                          2диспетчеризации

Установка вектора прерывания:
            SetIntVec(IntNo : byte; Vector : pointer)
где  IntNo  - номер вектора прерывания;
     Vector - адрес процедуры-обработчика прерывания.
Чтение вектора прерывания:
          GetIntVec(IntNo : byte; Var Vector : pointer)
где  IntNo  - номер вектора прерывания;

                              - 7 -
     Vector - переменная, в которую пишется адрес процедуры-обра-
ботчика прерывания.

       1Примечание. 0 Номер вектора прерывания от таймера - 8; номера
свободных  векторов для переустановки системного обработчика пре-
рываний от таймера: 60h-66h; 78h-7Fh.

Структура процедуры-обработчика прерывания:
Procedure Handler; interrupt;         {обязательный атрибут}
Begin
    ...
End {Handler}.

               2Технология реализации диспетчеризации

     Технология реализации диспетчеризации в среде Паскаль предс-
тавлена "заготовкой" программы:
Program User_Disp;
Procedure ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ; Assembler;
Asm
     ...
End;
Procedure СОЗДАТЬ_СОПРОГРАММУ;
Begin
     {Описана ранее}
End;
Procedure ПЕРЕДАТЬ_УПРАВЛЕНИЕ; Assembler;
Asm
     {Описана ранее}
End;
Procedure Handler; interrupt;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
    {Выбрать следующую сопрограмму}
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ;
End;
Procedure User_1;
Begin
      while true do begin

                              - 8 -
            ...
      end;
End;
Procedure User_2;
Begin
      while true do begin
            ...
        if УСЛОВИЕ then begin   {завершение выполнения}
           ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
           ВОССТАНОВИТЬ_ВЕКТОР_ПРЕРЫВАНИЯ_ОТ_ТАЙМЕРА;
           ПЕРЕДАТЬ_УПРАВЛЕНИЕ; {в главную программу}
        end;
      end;
End;
Begin
      СОЗДАТЬ_СОПРОГРАММУ; {User_1}
      СОЗДАТЬ_СОПРОГРАММУ; {User_2}
      ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
      ПЕРЕУСТАНОВИТЬ_ВЕКТОР_ПРЕРЫВАНИЯ_ОТ_ТАЙМЕРА;
      УСТАНОВИТЬ_НА_ВЕКТОР_8_ПРОЦЕДУРУ_Handler;
      ПЕРЕДАТЬ_УПРАВЛЕНИЕ; {в User_i}
End.

                              2Задание

     1. Реализовать программу, раскрыв все предложения оператора-
ми языка Паскаль.
     2. Нарисовать  состояния  стека произвольной сопрограммы при
приостановке ее прерыванием от таймера и возобновлении  из  обра-
ботчика прерываний.

      1Отчет должен содержать 0 текст программы  с  комментариями,  а
также рисунки, отражающие состояния стека сопрограмм при прерыва-
ниях.






                              - 9 -
                       2Лабораторная работа 3
      2ИССЛЕДОВАНИЕ ПРИНЦИПОВ  РЕАЛИЗАЦИИ ПРОЦЕССОВ И ОЧЕРЕДЕЙ
                        2МНОГОЗАДАЧНОГО ЯДРА

      1Цель работы 0 - ознакомление с принципами реализации процессов
и очередей в ядре многозадачной среды.

                          2Общие сведения

     Параллельно выполняемые  в многозадачной среде процедуры на-
зываются процессами.
     Поскольку процессор один,  а процессов много,  то появляется
средство упорядочения доступа процессов к процессору, принимающее
форму очереди.
     Важнейшим видом очереди является очередь процессов,  готовых
к выполнению.
     Для обеспечения возможности включения процесса в очереди не-
обходимо модифицировать дескриптор сопрограммы,  реализующей про-
цесс, введя в него поле - указатель на следующий процесс.
     С учетом возможности динамического  создания  и  уничтожения
представим процесс как объект следующего вида:
             ПРОЦЕСС = ОБЪЕКТ
  {ДАННЫЕ:}      ЭЛЕМЕНТЫ ДЕСКРИПТОРА СОПРОГРАММЫ;
                 СЛЕДУЮЩИЙ;
                 АДРЕС_СТЕКА;
  {МЕТОДЫ:}      Procedure ИНИЦИАЛИЗИРОВАТЬ;
                 Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
                 Procedure УСТАНОВИТЬ_СЛЕДУЮЩИЙ;
                 Function  ПОЛУЧИТЬ_СЛЕДУЮЩИЙ;
             КОНЕЦ;

     Вторым видом  объектов многозадачной среды является ОЧЕРЕДЬ,
представляемая следующим описанием:
             ОЧЕРЕДЬ = ОБЪЕКТ
    {ДАННЫЕ:}     НАЧАЛО;
    {МЕТОДЫ:}     Procedure ИНИЦИАЛИЗИРОВАТЬ;
                  Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
                  Procedure ВКЛЮЧИТЬ_ПРОЦЕСС;
                  Procedure ИСКЛЮЧИТЬ_ПРОЦЕСС;

                             - 10 -
                  Function  ПОЛУЧИТЬ_НАЧАЛО;
             КОНЕЦ;

     В данной  работе  рассматривается очередь готовых процессов,
которая может быть представлена как тип, производный от типа ОЧЕ-
РЕДЬ:
            ОЧЕРЕДЬ_ГОТОВЫХ = ОБЪЕКТ(ОЧЕРЕДЬ)
    {МЕТОДЫ:}     Procedure ИНИЦИАЛИЗИРОВАТЬ;
                  Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
                  Procedure ЗАПУСТИТЬ_ДИСПЕТЧЕР;
                  Procedure ОСТАНОВИТЬ_ДИСПЕТЧЕР;
                  Procedure ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;
                  Procedure АКТИВИЗИРОВАТЬ_СЛЕДУЮЩИЙ;
             КОНЕЦ;

    2Технология реализации процессов и очереди готовых процессов

     Технология реализации  процессов и очереди готовых процессов
представлена в виде словесного описания библиотечного модуля, яв-
ляющегося дальнейшим развитием программы лабораторной работы 2.
Unit DispObj;
Interface
Type
     ПРОЦЕСС = ОБЪЕКТ
         ЭЛЕМЕНТЫ ДЕСКРИПТОРА СОПРОГРАММЫ;
         СЛЕДУЮЩИЙ;
         АДРЕС_СТЕКА;
         Procedure ИНИЦИАЛИЗИРОВАТЬ;
         Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
         Procedure УСТАНОВИТЬ_СЛЕДУЮЩИЙ;
         Function  ПОЛУЧИТЬ_СЛЕДУЮЩИЙ;
     КОНЕЦ;
     ОЧЕРЕДЬ = ОБЪЕКТ
         НАЧАЛО;
         Procedure ИНИЦИАЛИЗИРОВАТЬ;
         Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
         Procedure ВКЛЮЧИТЬ_ПРОЦЕСС;
         Procedure ИСКЛЮЧИТЬ_ПРОЦЕСС;
         Function  ПОЛУЧИТЬ_НАЧАЛО;

                             - 11 -
     КОНЕЦ;
     ОЧЕРЕДЬ_ГОТОВЫХ = ОБЪЕКТ(ОЧЕРЕДЬ)
         Procedure ИНИЦИАЛИЗИРОВАТЬ;
         Procedure ОСВОБОДИТЬ_ПАМЯТЬ;
         Procedure ЗАПУСТИТЬ_ДИСПЕТЧЕР;
         Procedure ОСТАНОВИТЬ_ДИСПЕТЧЕР;
         Procedure ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;
         Procedure АКТИВИЗИРОВАТЬ_СЛЕДУЮЩИЙ;
     КОНЕЦ;
Var
     Readylist : ОЧЕРЕДЬ_ГОТОВЫХ;
Implementation
Procedure ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ; Assembler;
Asm
     ...
End;
Procedure РАЗРЕШИТЬ_ПРЕРЫВАНИЯ; Assembler;
Asm
     ...
End;
Procedure СОЗДАТЬ_СОПРОГРАММУ;
Begin
     ...
End;
Procedure ПЕРЕДАТЬ_УПРАВЛЕНИЕ; Assembler;
Asm
     ...
End;
Procedure Handler; interrupt;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
     Readylist.АКТИВИЗИРОВАТЬ_СЛЕДУЮЩИЙ;
End;
Procedure Idler;  {всегда в очереди готовых}
Begin
     while true do;
End;
Procedure ПРОЦЕСС.ИНИЦИАЛИЗИРОВАТЬ;
Begin

                             - 12 -
     СОЗДАТЬ_СОПРОГРАММУ;
     ЗАПОЛНИТЬ ПОЛЕ АДРЕС_СТЕКА;
End;
Procedure ПРОЦЕСС.ОСВОБОДИТЬ_ПАМЯТЬ;
Begin
     ОСВОБОДИТЬ ПАМЯТЬ, ЗАНЯТУЮ ПОД СТЕК;
End;
Procedure ПРОЦЕСС.УСТАНОВИТЬ_СЛЕДУЮЩИЙ;
Begin
      СЛЕДУЮЩИЙ := ...    ;
End;
Function  ПРОЦЕСС.ПОЛУЧИТЬ_СЛЕДУЮЩИЙ;
Begin
      ПОЛУЧИТЬ_СЛЕДУЮЩИЙ :=  СЛЕДУЮЩИЙ;
End;
Procedure ОЧЕРЕДЬ.ИНИЦИАЛИЗИРОВАТЬ;
Begin
      НАЧАЛО := NIL;
End;
Procedure ОЧЕРЕДЬ.ОСВОБОДИТЬ_ПАМЯТЬ;
Begin
     {Цикл по всем процессам очереди}
      ПРОЦЕСС.ОСВОБОДИТЬ_ПАМЯТЬ;
End;
Procedure ОЧЕРЕДЬ.ВКЛЮЧИТЬ_ПРОЦЕСС;
Begin
     ...
End;
Procedure ОЧЕРЕДЬ.ИСКЛЮЧИТЬ_ПРОЦЕСС;
Begin
     ...
End;
Function  ОЧЕРЕДЬ.ПОЛУЧИТЬ_НАЧАЛО;
Begin
      ПОЛУЧИТЬ_НАЧАЛО := НАЧАЛО;
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.ИНИЦИАЛИЗИРОВАТЬ;
Begin
     ОЧЕРЕДЬ.ИНИЦИАЛИЗИРОВАТЬ;

                             - 13 -
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.ОСВОБОДИТЬ_ПАМЯТЬ;
Begin
     ОЧЕРЕДЬ.ОСВОБОДИТЬ_ПАМЯТЬ;
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.ЗАПУСТИТЬ_ДИСПЕТЧЕР;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
     ПЕРЕУСТАНОВИТЬ_ВЕКТОР_ПРЕРЫВАНИЯ_ОТ_ТАЙМЕРА;
     УСТАНОВИТЬ_НА_ВЕКТОР_8_ПРОЦЕДУРУ_Handler;
     ПОЛУЧИТЬ_НАЧАЛО;
     ИСКЛЮЧИТЬ_ПРОЦЕСС;
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ;
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.ОСТАНОВИТЬ_ДИСПЕТЧЕР;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
     ВОССТАНОВИТЬ_ВЕКТОР_ПРЕРЫВАНИЯ_ОТ_ТАЙМЕРА;
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ; {в главную программу}
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
     ПРОЦЕСС.ИНИЦИАЛИЗИРОВАТЬ;
     ВКЛЮЧИТЬ_ПРОЦЕСС;
     РАЗРЕШИТЬ_ПРЕРЫВАНИЯ;
End;
Procedure ОЧЕРЕДЬ_ГОТОВЫХ.АКТИВИЗИРОВАТЬ_СЛЕДУЮЩИЙ;
Begin
     ЗАПРЕТИТЬ_ПРЕРЫВАНИЯ;
     ВКЛЮЧИТЬ_ПРОЦЕСС;     {текущий}
     ПОЛУЧИТЬ_НАЧАЛО;
     ИСКЛЮЧИТЬ_ПРОЦЕСС;
     ПЕРЕДАТЬ_УПРАВЛЕНИЕ;
End;
Begin
     Readylist.ИНИЦИАЛИЗИРОВАТЬ;
     Readylist.ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;{включение Idler}
End.

                             - 14 -
     С учетом приведенного библиотечного модуля  пользовательская
программа выглядит следующим образом:
Program User;
Uses Disp;
Procedure User_1;
Begin
      while true do begin
            ...
      end;
End;
Procedure User_N;
Begin
      while true do begin
            ...
          if УСЛОВИЕ then begin   {завершение выполнения}
             Readylist.ОСТАНОВИТЬ_ДИСПЕТЧЕР;
          end;
      end;
End;
Begin
     Readylist.ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;{включение User_1}
     Readylist.ДОБАВИТЬ_НОВЫЙ_ПРОЦЕСС;{включение User_N}
     Readylist.ЗАПУСТИТЬ_ДИСПЕТЧЕР;
End.
                              2Задание

     1. В  соответствии  с приведенными выше заготовками реализо-
вать библиотечный модуль,  обеспечивающий работу с очередью гото-
вых процессов, учитывая динамическое выделение памяти под процес-
сы.
     2. Составить пример, иллюстрирующий работу библиотечного мо-
дуля.

      1Отчет должен содержать 0 тексты программ библиотечного  модуля
и примера с комментариями.





                             - 15 -
                       2Лабораторная работа 4
      2ИССЛЕДОВАНИЕ СИСТЕМНЫХ ОЧЕРЕДЕЙ МНОГОЗАДАЧНОГО ЯДРА

      1Цель работы 0 - изучение системных очередей многозадачного яд-
ра.
                          2Общие сведения

     Самой важной системной очередью ядра является очередь  гото-
вых  процессов,  рассмотренная в лабораторной работе 3.  В данной
работе рассмотрим другие очереди ядра, которые принято относить к
системным.

                   2Очередь задержанных процессов

     Эта очередь даже проще очереди готовых  и  представлена  для
полноты  описания.  Дело в том,  что все невыполняющиеся процессы
должны находиться в каких-либо очередях.  Поэтому, если программ-
ной  системе  необходимо приостановить выполнение некоторого про-
цесса,  его необходимо поместить в специально выделенную очередь,
которую назовем очередью задержанных,  где он будет находиться до
тех пор, пока системе не понадобится его возобновить. В этом слу-
чае  процесс  извлекается  из  очереди задержанных и помещается в
очередь готовых процессов.
     Описание такой очереди может  выглядеть  следующим  образом:
Type
    List = Object
    First : Process;
    Constructor Init;
    Destructor  Done; Virtual;
    Procedure   Insert(P : Process);
    Procedure   Remove(P : Process);
End {List}.

              2Очередь процессов, задержанных на время

     Данный объект  выполняет  функции классической временной за-
держки выполнения программы,  например:  Delay(T : Word), которая
обеспечивает "активное" ожидание,  допустимое в однозадачной сре-
де.  В многозадачной среде при необходимости задержать процесс на

                             - 16 -
время  его  целесообразно  извлечь из очереди готовых и тем самым
распределять процессорное время уже между меньшим числом  процес-
сов.
     Технология реализации очереди,  выполняющей функции задержки
процессов на время, основана на следующих положениях:
     1. Мультизадачная среда "знает" текущее время, которое может
подсчитываться  по количеству вызовов диспетчера-обработчика пре-
рываний от таймера.
     2. В  момент обращения процесса к методу "задержать на время
Т" процесс переводится в очередь, а в специальное поле дескрипто-
ра процесса заносится время его активизации, равное сумме текуще-
го времени и интервала Т задержки.
     3. Диспетчер  на  каждом прерывании проверяет очередь задер-
жанных на наличие процессов,  для которых текущее время совпало с
временем их активизации, и переводит эти процессы в очередь гото-
вых.
     С учетом  приведенных положений описание очереди задержанных
будет выглядеть следующим образом:
Type
     DelayList = Object(List)
         Procedure Delay(T : Word);
         Procedure Activisation;
     End {DelayList}.
     Метод DelayList.Activisation помещается в диспетчер.

     Дадим словесное описание метода DelayList.Delay(T : Word).
Procedure DelayList.Delay(T : Word);
Var
     Предыдущий : Процесс;
Begin
     Предыдущий := Текущий;
     Предыдущий^.Tact := T + Tcur;
     Включить(Предыдущий);
     Текущий := Очередь_Готовых.Первый;
     Очередь_Готовых.Извлечь(Текущий);
     Передать_Управление(Предыдущий, Текущий);
End {DelayList.Delay}.
     Дадим словесное описание метода DelayList.Activisation:
Procedure DelayList.Activisation;

                             - 17 -
Var
     Текущий, Следующий : Процесс;
Begin
     Текущий := Первый;
     Пока Текущий <> NIL Делать Начало
           Следующий := Текущий^.Следующий;
           Если Текущий^.Tact = Tcur То Начало
                  Извлечь(Текущий);
                  Очередь_Готовых.Включить(Текущий);
           Конец {Если};
           Текущий := Следующий;
     Конец {Пока};
End {DelayList.Activisation}.

                  2Очередь уничтожаемых процессов

     Чтобы уничтожить процесс,  находящийся в какой-либо очереди,
его необходимо изъять из нее и разрушить дескриптор процесса. При
этом никаких проблем не возникает. Они появляются, когда требует-
ся уничтожить активный процесс,  т.е. выполняющийся в текущий мо-
мент времени.  Например, процесс закончил выполнение предписанных
ему действий и желает самоуничтожиться. В этом случае просто раз-
рушить дескриптор процесса нельзя, так как управление от активно-
го  процесса передается первому в очереди готовых процессов через
их дескрипторы,  и если дескриптор активного процесса  разрушить,
то функции Transfer(Old,  New :  Process) будет передан указатель
на несуществующий дескриптор и система зависнет.
     Поэтому технология  корректного уничтожения процесса состоит
в следующем:
     1. Процесс,  желающий самоуничтожиться, переводится в специ-
альную очередь уничтожаемых процессов, а его дескриптор не разру-
шается.
     2. Диспетчер на каждом прерывании очищает очередь уничтожае-
мых процессов, разрушая их дескрипторы.
     С учетом приведенных положений описание очереди уничтожаемых
процессов выглядит следующим образом:
Type
     KillList = Object(List)
         Procedure SelfInsert;

                             - 18 -
         Procedure Clear;
     End {KillList}.
     Метод KillList.Clear  вызывается  из процедуры диспетчера на
каждом прерывании от таймера.
     Дадим словесное описание метода KillList.Clear.
Procedure KillList.Clear;
Var
     Временный : Процесс;
Begin
     Пока Первый <> NIL Делать Начало
          Временный := Первый;
          Первый    := Временный^.Следующий;
          Разрушить(Временный);
     Конец {Пока};
End {KillList.Clear}.

     Примитив ядра УНИЧТОЖИТЬ_ПРОЦЕСС(P :  ПРОЦЕСС) выглядит сле-
дующим образом KillList.Insert(P).
     При самоуничтожении  процесс  должен  обратиться  к  методу:
KillList.SelfInsert.
     Заметим, что процесс никогда не должен заканчиваться выходом
на End процедуры,  которая его описывает,  а только вызовом Kill-
List.SelfInsert.

                              2Задание

     1. Используя  материалы  предыдущих  лабораторных  работ   и
представленное выше описание системных очередей, реализовать объ-
екты: очередь задержанных процессов, очередь процессов, задержан-
ных на время, очередь уничтожаемых процессов.
     2. Добавить перечисленные объекты в библиотечный модуль, ре-
ализующий ядро.
     3. Реализовать программу,  демонстрирующую работоспособность
разработанных объектов.

      1Отчет должен содержать 0 тексты программы и библиотечного  мо-
дуля с комментариями.



                             - 19 -
                       2Лабораторная работа 5
           2ИССЛЕДОВАНИЕ МЕТОДОВ СИНХРОНИЗАЦИИ ПРОЦЕССОВ

      1Цель работы 0  - знакомство с методами синхронизации процессов
на основе семафоров.

                          2Общие сведения

     Синхронизацией называется  обеспечение  заданной очередности
прохождения процессов через определенные состояния.
     Наиболее часто  синхронизация требуется для координации дос-
тупа нескольких процессов к одному разделяемому ресурсу.
     Рассмотрим простейший пример.  Предположим, что два процесса
выводят информацию в виде символа в разные точки экрана.
     Фрагмент текста процедур,  соответствующих процессам, выгля-
дит следующим образом:
          Процесс 1                         Процесс 2

     (1)  GoTo(X,Y);                (3)     GoTo(X,Y);
     (2)  Write(Ch);                (4)     Write(Ch);

     При выполнении процессов в режиме разделения времени возмож-
на ситуация,  когда оператором GoTo(X,Y) курсор устанавливается в
нужную точку экрана одним процессом, затем диспетчер передает уп-
равление другому процессу, который в это время выполняет операцию
вывода  символа.  То есть очередность выполнения действий такова:
1,  3,  2,  4 или 3, 1, 4, 2. Очевидно, что в этом случае один из
процессов выведет информацию не в то место экрана,  куда планиро-
вал.
     Суть исправления ошибки состоит  в  обеспечении  неделимости
выполнения последовательности действий GoTo(X,Y) и Write(Ch).

     В более общем смысле ситуация представляется следующим обра-
зом. Экран в данном случае выступает в роли разделяемого ресурса,
который совместно и одновременно используют два процесса.  Ошибка
возникает при отсутствии регламентации доступа к разделяемому ре-
сурсу,  которая заключается в том, что если один процесс работает
с  общим ресурсом,  то другой не должен в это же время работать с
ним.

                             - 20 -
     Используемый совместно несколькими процессами ресурс называ-
ется критическим,  участок программы процесса, реализующий работу
с критическим ресурсом, называется критическим участком, а режим,
при котором только один процесс в произвольный момент времени мо-
жет работать с критическим ресурсом (или находиться в критическом
участке), называется режимом взаимного исключения.
     В системах реального  времени  пренебрежение  регламентацией
доступа  нескольких процессов к критическому ресурсу может приво-
дить к катастрофическим последствиям.

          2Методы обеспечения режима взаимного исключения

     Можно выделить три принципиальных  пути  обеспечения  режима
взаимного исключения.
      11) Запрет прерываний на входе в критический участок и разре-
 1шение прерываний на выходе из него.
     В этом случае фрагмент программы работы с критическим участ-
ком выглядит следующим образом:
                     Запрет прерываний:
                        Критический участок;
                     Разрешение прерываний.

     Первым и единственным в свой критический участок войдет  тот
процесс,  который  первым  доберется  до инструкции CLI в функции
 1"Запрет прерываний" 0.  Прерывания будут запрещены, диспетчер прек-
ратит  работу  и  все  другие процессы естественным образом будут
приостановлены.  После выхода из критического участка  прерывания
будут  разрешены  и  какой-то  другой процесс сможет войти в свой
критический участок.
     Такой способ организации взаимного исключения  обладает  су-
щественными недостатками:
     - при запрете прерываний система становится слепой и  глухой
к внешним воздействиям окружающей среды, которые формируются, как
правило, через систему прерываний;
     - приостанавливаются даже те процессы, которые вообще не ра-
ботают с данным ресурсом.
     Поэтому данный  способ организации взаимного исключения при-
меняется в тех случаях, когда критический участок очень короткий,
например, несколько инструкций.

                             - 21 -
      12) Активное ожидание.
     В этом случае вводится некоторый флаг занятости ресурса, ко-
торый проверяется процессом перед тем,  как войти  в  критический
участок.  Если флаг,  который вначале устанавливается в состояние
СВОБОДЕН,  находится в состоянии СВОБОДЕН,  то процесс  переводит
его в состояние ЗАНЯТ и входит в критический участок.  При выходе
из него процесс устанавливает флаг в состояние СВОБОДЕН. Если при
подходе  к  критическому участку флаг оказывается в состоянии ЗА-
НЯТ, то процесс начинает проверять состояние флага в цикле до тех
пор,  пока  флаг  не будет установлен в состояние СВОБОДЕН другим
процессом.
     Фрагменты процедуры,  описывающие  процесс на этапах входа в
критический участок и выхода из него, выглядят следующим образом:

              Инициализация: FLAG := СВОБОДЕН;

              While FLAG = ЗАНЯТ Do Begin
              End {While};
              FLAG := ЗАНЯТ;
                   Критический участок;
              FLAG := СВОБОДЕН;

     В данном  случае  сам  флаг  является критическим ресурсом и
доступ к нему должен производиться в режиме взаимного исключения.
Фрагмент  входа  в  критический  участок с проверкой и установкой
флага в режиме взаимного исключения  выглядит  следующим  образом
(состоянию ЗАНЯТ соответствует FLAG = 1):
                       LBL : STI
                             CLI
                             CMP  FLAG, 1
                             JZ   LBL
                             MOV  FLAG, 1
                             STI
     Если чтение и установку флага выполнять за одну  инструкцию,
которая является неделимым действием, то вход в критический учас-
ток можно выполнить более элегантно, а именно:
                             MOV  AX, 1
                       LBL : XCHG AX, FLAG
                             CMP  AX, 1

                             - 22 -
                             JZ   LBL

     Недостатком приведенного  метода реализации взаимного исклю-
чения является активное ожидание, т. е. процесс, который ждет ос-
вобождения ресурса,  занимает процессор в отводимые ему диспетче-
ром кванты времени,  хотя и не выполняет никаких  полезных  дейс-
твий.
     Поэтому в случае ожидания освобождения ресурса целесообразно
извлечь  процесс  из очереди готовых процессов и не предоставлять
ему бесполезно используемых квантов времени.  На  этом  положении
основано использование семафоров как средств взаимного исключения
при доступе к критическому ресурсу.

      13) Семафоры.
     Семафор представляет собой объект, включающий счетчик и оче-
редь. В очередь помещаются процессы, ждущие наступления некоторо-
го события, например освобождения ресурса. Условия помещения про-
цесса в очередь и извлечения из нее с целью активизации определя-
ются состоянием счетчика и проверяются двумя операциями над сема-
фором, которые называются P- и V- операциями.
     Принципы работы с семафором можно описать следующим образом.
В исходном состоянии семафор открыт.  Процесс проходит через отк-
рытый семафор в критический участок и закрывает за собой семафор.
Другой процесс,  подходя к критическому  участку,  натыкается  на
закрытый  семафор и вынужден ждать его открытия в очереди семафо-
ра.  Процесс, выходя из критического участка, открывает семафор и
активизирует  первый  в очереди семафора процесс,  который теперь
может войти в критический участок и также закрыть за собой  сема-
фор.
     Состояние счетчика семафора играет роль индикатора занятости
ресурса.  Принято инициализировать счетчик в 1,  декрементировать
его при подходе к критическому участку (Р - операция) и инкремен-
тировать при выходе из критического участка (V - операция). Таким
образом,  равенство нулю счетчика свидетельствует  о  возможности
входа  в  критический участок,  а отрицательное значение счетчика
свидетельствует о наличии процесса в критическом участке и  необ-
ходимости блокировки, т. е. о переводе в очередь семафора с пере-
дачей управления другим процессам.


                             - 23 -
                  2Технология реализации семафора

     Технология реализации  семафора представлена в виде описания
семафора как объекта языка программирования.
Type
    PSemaphore = ^TSemaphore;
    TSemaphore = Object
            Счетчик          : Целое;
            Очередь_семафора : Очередь процессов;
            Constructor Init(С : Целое);
            Destructor  Done;   Virtual;
            Procedure   P;
            Procedure   V;
    End {TSemaphore}.
Constructor TSemaphore.Init(Целое);
Begin
      Счетчик := С;
      Создать Очередь_семафора;
End {TSemaphore.Init};
Destructor TSemaphore.Done;
Begin
      Разрушить Очередь_семафора;
End {TSemaphore.Done};
Procedure TSemaphore.P;
Var
     Предыдущий : Процесс;
Begin
     Запретить_прерывания;
     Счетчик := Счетчик - 1;
     If Счетчик < 0 Then Begin {блокировать процесс}
        Предыдущий := Текущий;
        Очередь_семафора.Включить(Предыдущий);
        Текущий := Очерередь_готовых.Первый;
        Очередь_готовых.Извлечь(Текущий);
        Передать_управление(Предыдущий, Текущий);
     End {If};
     Разрешить_прерывания;
End {TSemaphore.P};


                             - 24 -
Procedure TSemaphore.V;
Var
     Предыдущий : Процесс;
Begin
     Запретить_прерывания;
     Счетчик := Счетчик + 1;
     If Счетчик <= 0 Then Begin {активизировать процесс}
             Предыдущий := Текущий;
             Очередь_готовых.Включить(Предыдущий);
             Текущий := Очередь_семафора.Первый;
             Очередь_семафора.Извлечь(Текущий);
             Передать_управление(Предыдущий, Текущий);
     End {If};
     Разрешить_прерывания;
End {TSemaphore.V}.

     Здесь процесс,  вызвавший метод TSemaphore.V,  переводится в
очередь готовых и активизирует процесс,  стоящий первым в очереди
семафора.

                2Технология использования семафоров

     В первую очередь семафоры используются как средства взаимно-
го исключения при доступе к критическому ресурсу. Правило исполь-
зования семафора в этом случае представлено в виде фрагмента про-
цедуры, описывающей процесс при входе в критический участок и вы-
ходе из него.

Раздел описания:
Var
     Semaphore : TSemaphore;
Раздел инициализации:
     Semaphore.Init(1);

Процесс при работе с критическим участком:
     Semaphore.P;
           Критический участок;
     Semaphore.V;


                             - 25 -
Завершение работы с семафором:
     Semaphore.Done;

     Семафоры могут  быть  использованы не только для координации
доступа к критическому ресурсу нескольких процессов, но и для ус-
тановления  требуемой  очередности прохождения процессами опреде-
ленных состояний.  Пусть,  например, необходимо, чтобы процесс Р1
прошел через состояние,  отмеченное меткой М_Р1,  например чтение
из ячейки памяти П, только после того, как процесс Р2 пройдет че-
рез состояние,  отмеченное меткой М_Р2,  например запись в ячейку
памяти П, т.е. запись должна произойти раньше чтения.
     С помощью семафора данная задача решается следующим образом:

     Инициализация семафора:   Semaphore.Init(0);

     Процесс Р1                        Процесс Р2

            Semaphore.P;
     М_Р1 : Чтение из П;               М_Р2 : Запись в П;
                                              Semaphore.V;

     Если процесс Р1 подойдет к метке М_Р1 раньше, чем процесс Р2
- к метке М_Р2,  то он будет вынужден блокироваться в очереди се-
мафора.  Процесс Р2, выполнив запись в ячейку П, вызовет Semapho-
re.V и тем самым активизирует процесс Р1,  позволив ему выполнить
чтение только после того как осуществлена запись.
     Часто процессы реализуются в виде бесконечных циклов, поэто-
му,  чтобы избежать нескольких записей в ячейку П одним процессом
до момента чтения из нее другим процессом, необходимо последующие
записи  осуществлять  только  после очередного чтения.  Указанная
схема реализуется следующим образом:

           Инициализация семафора: Semaphore1.Init(0);

           Инициализация семафора: Semaphore2.Init(0);





                             - 26 -
            Процесс Р1                        Процесс Р2

     While True Do Begin              While True Do Begin
          . . .                            . . .
            Semaphore1.P;
     М_Р1 : Чтение из П;              М_Р2 : Запись в П;
            Semaphore2.V;                    Semaphore1.V;
                                             Semaphore2.P;
          . . .                            . . .
     End {While};                     End {While}.

     Теперь процесс Р2,  выполнив запись и сигнализировав об этом
вызовом Semaphore1.V,  ожидает, приостановленный вызовом Semapho-
re2.P,  чтения процессом Р1, о чем Р1 будет сигнализировать вызо-
вом Semaphore2.V.  В этой схеме методы семафора Semaphore2 служат
для ожидания и посылки квитанции, подтверждающей чтение.

                              2Задание

     1. Реализовать объект - семафор,  используя средства, разра-
ботанные при выполнении лабораторных работ 1 - 4.
     2. Написать демонстрационную программу, иллюстрирующую коор-
динацию  доступа  к критическому ресурсу с помощью реализованного
семафора.
     3. Написать демонстрационную программу, иллюстрирующую синх-
ронизацию прохождения процессов через  определенные  состояния  с
помощью реализованного объекта - семафор.

      1Отчет должен содержать 0 текст библиотечного модуля,  включаю-
щего описание и реализацию объекта - семафор, тексты демонстраци-
онных программ с комментариями, таблицы состояний счетчиков сема-
форов  при  различных вариантах очередности прохождения процессов
(для числа процессов,  большего чем 2) через вызовы P и V исполь-
зуемых семафоров.






                             - 27 -
                       2Лабораторная работа 6
            2ИССЛЕДОВАНИЕ МЕТОДОВ БУФЕРИЗАЦИИ СООБЩЕНИЙ

      1Цель работы 0  - изучение метода обмена сообщениями между про-
цессами с помощью буфера.

                          2Общие сведения

     Буферизация является средством согласования скорости  записи
сообщений  одним процессом и скорости их чтения другим.  При этом
буфер является общим,  разделяемым объектом для пишущего и читаю-
щего процессов.
     Существуют следующие  требования к алгоритмам функционирова-
ния буфера:
     1) нельзя записать сообщение в полный буфер; процесс, делаю-
щий такую попытку,  должен быть блокирован до появления свободной
ячейки в буфере;
     2) нельзя прочитать сообщение из  пустого  буфера;  процесс,
делающий такую попытку, должен быть блокирован до появления сооб-
щения в буфере.
     Как правило, механизмы синхронизации записи в буфер и чтения
из буфера являются скрытыми для пользователя, которому предостав-
ляются лишь примитивы СОЗДАТЬ,  УНИЧТОЖИТЬ, ЗАПИСАТЬ и ПРОЧИТАТЬ,
внешне напоминающие работу с файлами.
     Простейший вариант  синхронизации записи и чтения для буфера
размером в 1 ячейку памяти был рассмотрен в  лабораторной  работе
5. В данной работе рассматривается общий случай буфера размером в
N элементов.
                         2Структура буфера

     Буфер представляет собой массив из N элементов определенного
типа. Состояние буфера описывается количеством сообщений n, нахо-
дящихся в буфере,  и двумя индексами - индексом out чтения и  ин-
дексом in записи.
     Запись в буфер предваряется проверкой условия "буфер полон",
т. е. n = N, а чтение из буфера - проверкой условия "буфер пуст",
т. е. n = 0.
     Выполнение условия "буфер полон" означает,  что скорость за-
писи превысила скорость чтения, а выполнение условия "буфер пуст"

                             - 28 -
означает,  что скорость чтения выше скорости записи. В нормальном
состоянии значение индекса записи немного превышает значение  ин-
декса чтения, что иллюстрируется следующим рисунком:
                    ┌──────────────────┐
                    │                  │
                    ├──────────────────┤
                    │//////////////////│ ─────────> Out чтение
                    ├──────────────────┤
                    │//////////////////│ (Следующее чтение)
                    ├──────────────────┤
                    │//////////////////│
                    ├──────────────────┤
 Запись in ──────>  │                  │
                    ├──────────────────┤
 (Следующая запись) │                  │
                    └──────────────────┘
     Обычно буфер рассматривается как кольцевой,  т. е. после за-
писи в последнюю ячейку буфера запись продолжается с первой ячей-
ки, чтение осуществляется аналогично.
     Синхронизация записи  и  чтения  реализуется  использованием
очередей ожидания двух видов:
     - очереди процессов,  ждущих записи,  когда буфер  полон;
     - очереди процессов, ждущих чтения, когда буфер пуст.

                          2Описание буфера

     Представим буфер в виде объекта:
        TBuffer = Object
           in, out    : [0..N-1];
           n          : [0..N];
           Buf        : Array[0..N-1] Of AnyType;
           ReadList, WriteList  : TList;
           Constructor Init;
           Destructor  Done; Virtual;
           Procedure   Write(M : AnyType);
           Procedure   Read(Var M : AnyType);
           Procedure   Wait_Read;
           Procedure   Signal_Read;
           Procedure   Wait_Write;

                             - 29 -
           Procedure   Signal_Write;
        End {TBuffer}.
Constructor TBuffer.Init;
Begin
        in  := 0; out := 0; n := 0;
        ReadList.Init;
        WriteList.Init;
End {TBuffer.Init};
Destructor TBuffer.Done;
Begin
        ReadList.Done;
        WriteList.Done;
End {TBuffer.Done};
     Синхронизация записи и чтения реализуется следующими четырь-
мя методами объекта - буфера.
Procedure TBuffer.Wait_Read;
{заставляет процесс ждать чтения, если буфер пустой}
Var
          Предыдущий : Процесс;
Begin
          Предыдущий := Текущий;
          ReadList.Включить(Предыдущий);
          Текущий := Очередь_готовых.Первый;
          Очередь_готовых.Извлечь(Текущий);
          Передать_управление(Предыдущий, Текущий);
End {TBuffer.Wait_Read};
Procedure TBuffer.Wait_Write;
{заставляет процесс ждать записи, если буфер полный}
Var
          Предыдущий : Процесс;
Begin
          Предыдущий := Текущий;
          WriteList.Включить(Предыдущий);
          Текущий := Очерередь_готовых.Первый;
          Очередь_готовых.Извлечь(Текущий);
          Передать_управление(Предыдущий, Текущий);
End {TBuffer.Wait_Write};
Procedure TBuffer.Signal_Read;
{"сигнализирует" о том, что произведена запись и возможна активи-

                             - 30 -
  зация одного из процессов, ждущих чтения}
Var
          Локальный : Процесс;
Begin
          Локальный := ReadList.Первый;
          If Локальный <> NIL Then Begin   {очередь не пустая}
             ReadList.Извлечь(Локальный);
             Очередь_готовых.Включить(Локальный);
          End {If};
End {TBuffer.Signal_Read}.
Procedure TBuffer.Signal_Write;
{"сигнализирует" о том, что произведено чтение и возможна активи-
  зация одного из процессов, ждущих записи}
Var
          Локальный : Процесс;
Begin
          Локальный := WriteList.Первый;
          If Локальный <> NIL Then Begin   {очередь не пустая}
             WriteList.Извлечь(Локальный);
             Очередь_готовых.Включить(Локальный);
          End {If};
End {TBuffer.Signal_Write}.
Procedure TBuffer.Write(M : AnyType);
Begin
        Запретить прерывания;
        If n = N Then Wait_Write; {буфер полный}
        n := n + 1;
        Buf[in] := M;
        in := (in + 1) MOD N;
        Signal_Read;
        Разрешить прерывания;
End {TBuffer.Write};
Procedure TBuffer.Read(Var M : AnyType);
Begin
        Запретить прерывания;
        If n = 0 Then Wait_Read; {буфер пустой}
        n := n - 1;
        М := Buf[out];
        out := (out + 1) MOD N;

                             - 31 -
        Signal_Write;
        Разрешить прерывания;
End {TBuffer.Read};
     В методах Signal_Read и Signal_Write управление не передает-
ся активизируемым процессам,  а они лишь ставятся в очередь гото-
вых процессов. Это может породить неопределенность, так как неиз-
вестно,  что будет с буфером,  когда до их выполнения дойдет оче-
редь. Поэтому активизацию процессов лучше выполнять не до включе-
ния в очередь готовых процессов, а до передачи управления активи-
зируемому процессу.  Метод Signal_Read для этого случая представ-
лен ниже, а метод Signal_Write реализуется аналогично.
Procedure TBuffer.Signal_Read;
Var
          Предыдущий, Локальный  : Процесс;
Begin
          Локальный := ReadList.Первый;
          If Локальный <> NIL Then Begin   {очередь не пустая}
             Предыдущий := Текущий;
             Текущий    := Локальный;
             ReadList.Извлечь(Локальный);
             Очередь_готовых.Включить(Предыдущий);
             Передать_управление(Предыдущий, Текущий);
          End {If};
End {TBuffer.Signal_Read}.

                              2Задание

     1. Реализовать  объект - буфер в библиотечном модуле для не-
которого типа передаваемых данных.
     2. Написать демонстрационную программу, иллюстрирующую рабо-
ту буфера при различных скоростях записи и чтения сообщений. Ско-
рости записи и чтения можно  менять  путем  изменения  количества
процессов, пишущих в буфер или читающих из него, или включая опе-
раторы задержки между следующими действиями:
     - порождением сообщения и записью его в буфер;
     - чтением сообщения из буфера и обработкой сообщения.

      1Отчет должен содержать 0 текст  программы  с  комментариями  и
библиотечный модуль с реализацией буфера.

                             - 32 -
                       2Лабораторная работа 7
      2ИССЛЕДОВАНИЕ МЕТОДА ВЗАИМОДЕЙСТВИЯ ПРОЦЕССОВ С ПОМОЩЬЮ
                        2ОЧЕРЕДЕЙ СООБЩЕНИЙ

      1Цель работы 0  -  изучение  методов взаимодействия процессов с
помощью очередей сообщений.

                          2Общие сведения

     Обмен сообщениями  между процессами на основе буфера,  расс-
мотренный в лабораторной работе 6,  обладает рядом недостатков, а
именно:
     - ограничено (размером буфера) количество сообщений, помеща-
емых в буфер;
     - сообщения переписываются в буфер и читаются из буфера, та-
ким образом времена записи и чтения определяются типом (размером)
сообщения и могут быть большими.
     Поэтому в ряде операционных сред,  а именно:  UNIX, OS/2 су-
ществует другое средство обмена сообщениями,  называемое очередью
сообщений и включающее кроме нее еще и средства синхронизации за-
писи и чтения.
     В качестве последних выступают очереди процессов,  пославших
сообщение и ждущих его.
     Дадим словесное  описание методов записи и чтения сообщения,
а затем опишем данное средство обмена сообщениями как объект опе-
рационной среды.
     Запись сообщения включает в себя следующие действия:
     - включение указателя на сообщение в очередь (обратим внима-
ние, что именно указатель помещается в очередь, а не само сообще-
ние, что существенно повышает скорость обмена);
     - включение  процесса,  пославшего сообщение в очередь,  тем
самым процесс, пославший сообщение, блокируется до момента чтения
его другим процессом;
     - активизацию процесса, ждущего сообщения, если таковой име-
ется.
     Чтение сообщения включает в себя следующие действия:
     - блокировку  процесса путем постановки его в очередь,  если
сообщения отсутствуют;
     - чтение сообщения, если оно поступило;

                             - 33 -
     - активизацию процесса, пославшего сообщение.
     Таким образом, процесс, пославший сообщение, возобновит свое
выполнение  только после того,  как его сообщение будет прочитано
другим процессом.
     Схематично взаимодействия процессов для случаев, когда обра-
щение  одного  процесса  к  примитиву записи сообщения происходит
раньше обращения другого процесса к примитиву чтения, и наоборот,
представлены на рис. 7.1 и 7.2.
    Процесс 1                                        Процесс 2
┌──────┴──────┐                                         │
│    Запись   │                                         │
└──────┬──────┘                                         │
       │Ожидание                                        │
┌──────┴──────┐                                 ┌───────┴───────┐
│Возобновление│                                 │     Чтение    │
└──────┬──────┘---------------------------------└───────┬───────┘
     Рис.7.1. Процесс  1  подошел к примитиву записи раньше,  чем
              процесс 2 подошел к примитиву чтения

     Процесс 1                                        Процесс 2
        │                                         ┌──────┴──────┐
        │                                         │Начало чтения│
        │                                         └──────┬──────┘
        │                                     Ожидание   │
┌───────┴───────┐                                 ┌──────┴──────┐
│    Запись     │                                 │Конец  чтения│
└───────┬───────┘---------------------------------└──────┬──────┘
     Рис.7.2. Процесс  1  подошел  к примитиву записи позже,  чем
              процесс 2 подошел к примитиву чтения

     Средство обмена  сообщениями,  удовлетворяющее  приведенному
выше описанию, может быть представлено следующим образом:
ТPostBox = Object
    MessageList  : TMessageList;{очередь указателей на сообщения}
    SendProcList : TList;{очередь процессов, пославших сообщения}
    WaitProcList : TList;  {очередь процессов. ждущих сообщение}
    Constructor Init;
    Destructor  Done; Virtual;
    Procedure   PutMsg(M : Pointer); {послать сообщение}

                             - 34 -
    Function    GetMsg   : Pointer;  {принять сообщение}
End {TPostBox}.

     Очередь указателей на сообщения имеет методы,  очень похожие
на методы процессов,  за исключением того,  что оперирует с типом
данных Pointer,  а не с типом данных Процесс.
Constructor TPostBox.Init;
Begin
     MessageList.Init;
     SendProcList.Init;
     WaitProcList.Init;
End {TPostBox.Init};
Destructor TPostBox.Done;
Begin
     MessageList.Done;
     SendProcList.Done;
     WaitProcList.Done;
End {TPostBox.Done};
Procedure TPostBox.PutMsg(M : Pointer);
Var
     Предыдущий : Процесс;
Begin
     Запретить_прерывания;
     MessageList.Insert(M);
     Предыдущий :=  Текущий;
     SendProcList.Insert(Предыдущий);
     If WaitProcList.Первый <> NIL Then Begin
        Текущий := WaitProcList.Первый;
        WaitProcList.Remove(Текущий);
     End Else Begin
        Текущий := Readylist.Первый;
        Readylist.Remove(Текущий);
     End {If};
     Передать_управление(Предыдущий, Текущий);
     Разрешить_прерывания;
End  {TPostBox.PutMsg};
Function TPostBox.GetMsg : Pointer;
Var
     M          : Pointer;

                             - 35 -
     S          : Процесс;
     Предыдущий : Процесс;
Begin
     Запретить_прерывания;
     If MessageList.Первый = NIL Then Begin
        Предыдущий := Текущий;
        WaitProcList.Insert(Предыдущий);
        Текущий := Readylist.Первый;
        Readylist.Remove(Текущий);
        Передать_управление(Предыдущий, Текущий);
        Запретить_прерывания;
     End {If};
     M := MessageList.Первый;
     MessageList.Remove(M);
     GetMsg := M;
     S := SendProcList.Первый;
     SendProcList.Remove(S);
     Readylist.Insert(S);
     Разрешить_прерывания;
End {TPostBox.GetMsg}.

     Представленный объект  лишь моделирует в среде MS DOS работу
очередей сообщений,  реализованных в системах UNIX и OS/2, однако
дает  представление о путях решения задачи синхронизации записи и
чтения сообщений разными процессами.
     С точки  зрения  синхронизации записи и чтения,  состоящей в
том,  что процессы возобновляют работу только после того, как за-
пись и чтение завершены,  представленный объект похож на механизм
Рандеву языка реального времени Ада.

                              2Задание

     1. Реализовать объект TPostBox средствами языка Pascal.
     2. Прокомментировать каждую строчку объекта TPostBox.
     3. Написать демонстрационную программу, иллюстрирующую функ-
ционирование объекта TPostBox.

      1Отчет должен содержать 0 текст  программы  с  комментариями  и
библиотечный модуль с реализацией очереди сообщений.


                            2Содержание

     Лабораторная работа 1.  ИЗУЧЕНИЕ АЛГОРИТМОВ РЕАЛИЗАЦИИ И ИС-
ПОЛЬЗОВАНИЯ СОПРОГРАММ .........................................3
     Лабораторная работа 2.  ИССЛЕДОВАНИЕ ПРИНЦИПОВ ДИСПЕТЧЕРИЗА-
ЦИИ ПРОЦЕССОВ ..................................................6
     Лабораторная работа 3.  ИССЛЕДОВАНИЕ   ПРИНЦИПОВ  РЕАЛИЗАЦИИ
ПРОЦЕССОВ И ОЧЕРЕДЕЙ МНОГОЗАДАЧНОГО ЯДРА .......................9
     Лабораторная работа 4.  ИССЛЕДОВАНИЕ СИСТЕМНЫХ ОЧЕРЕДЕЙ МНО-
ГОЗАДАЧНОГО ЯДРА...............................................15
     Лабораторная работа 5.  ИССЛЕДОВАНИЕ  МЕТОДОВ СИНХРОНИЗАЦИИ
ПРОЦЕССОВ .....................................................19
     Лабораторная работа 6.  ИССЛЕДОВАНИЕ МЕТОДОВ БУФЕРИЗАЦИИ СО-
ОБЩЕНИЙ .......................................................27
     Лабораторная работа 7.  ИССЛЕДОВАНИЕ МЕТОДА ВЗАИМОДЕЙСТВИЯ
ПРОЦЕССОВ С ПОМОЩЬЮ ОЧЕРЕДЕЙ СООБЩЕНИЙ.........................32














                      Редактор Э.К.Долгатов
                Лицензия ЛР N 020617 от 10.08.92
  ____________________________________________________________
  Подписано в печать   .  .97. Формат 60х84 1/16. Бумага тип.N2.
  Печать офсетная.  Усл.печ.л.  2,09.  Уч.-изд.л.  2,25.
  Тираж 65 экз. Заказ
  Издательско-полиграфический центр  ГЭТУ
  _____________________________________________________________
             197376, С.-Петербург, ул.Проф.Попова, 5
