{
 Š®à®ç¥ â ª. â  ¡¨¡«¨®â¥ª  ï¢«ï¥âáï Shareware â.¥ ¢ë ¬®¦¥â¥ ¥¥ ¨á¯®«ì§®¢ âì
¤«ï «î¡ëå …ŠŽŒŒ…—…‘Šˆ• æ¥«¥©. •®âï ¥á«¨ ­ ©¤¥â¥ ¥© ª®¬¬¥àç¥áª®¥ ¯à¨¬¥­¥­¨¥
¯¨è¨â¥ ¨«¨ §¢®­¨â¥, ¯®£®¢®à¨¬.
‚ ­ áâ®ïé¨© ¬®¬¥­â ®­  ¢ë¯®«­ï¥â â®«ìª® ¡ §®¢ë¥ ä-¨¨, ¤  ¨ â¥ ­¥ ¢á¥ â.¥ ­ ¤
­¥© ­ ¤® ¥é¥ à ¡®â âì ¨ à ¡®â âì.
ã¤ã ¯à¨§­ â¥«¥­ ¢á¥¬ §  «î¡ë¥ à¥æ¥­§¨¨ ¨ ¤®¯®«­¥­¨ï ª íâ®© ¡¨¡«¨®â¥ª¥.
…á«¨ ¡ã¤ãâ ¢®¯à®áë, § ¤ ¢ ©â¥ ­¥ áâ¥á­ï©â¥áì.
|à¨ à §à ¡®âª¥ ¨á¯®«ì§®¢ «áï Turbo Pascal v. 7.0, ¡ §¨àã¥âáï ­  TBufStream ¨§ ’Vision.
|” ©«ë .dbf ¯®ãç ¥¬ë¥ ¯à¨ à ¡®â¥ ¡ã¤ãâ ª ª à®¤­ë¥ FoxBase / Foxpro,   ä ©«ë ¨§ íâ¨å á¨áâ¥¬
|¡ã¤ãâ ª ª à®¤­ë¥ ¤«ï dbFile. „àã£¨¥ á¨áâ¥¬ë ï ­¥ ¯à®¡®¢ «.

                             Good Luck!
                                                 £.¥­§ .  "‘â àâ-7"
                                                 â¥«.(8412) 69-27-90
                                                 E-Mail: Start7@systema.penza.su
                                                 ˆ«ìï …¢£¥­ì¥¢¨ç —ã¡ à®¢
}

{$B-}
{$T-}
{$F-}
{$X+}
{
    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿       ÚÄÄÄ¿
    Ã  § £®«®¢®ç­ë©  ¡ ©â                            ÃÄÄÄÄÄÄ>³ 7 ³ ¯®¤ª«îç¥­ «¨ DBT
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÃÄÄÄ´
    Ã  ¤ â               ÄÄ £®¤   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ³ 6 ³
 3  Ã  ¯®á«¥¤­¥©         ÄÄ ¬¥áïæ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÃÄÄÄ´
    Ã  ¬®¤¨ä¨ª æ¨¨       ÄÄ ¤¥­ì  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ³ 5 ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÃÄÄÄ´
    Ã                                                ³       ³ 4 ³
    Ã  ç¨á«® § ¯¨á¥©                                 ³       ÃÄÄÄ´
 4  Ã  (¡¥§ §­ ª )                                   ³       ³ 3 ³
    Ã                                                ³       ÃÄÄÄ´
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ³ 2 Ã¿
    Ã  ¯®«­ ï ¤«¨­  § £®«®¢ª                         ³       ÃÄÄÄ´³ ®¬¥à
 2  Ã  (¢ª«îç ï ¤¥áªà¨¯â®àë)                         ³       ³ 1 ³Ã
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÃÄÄÄ´³ ¢¥àá¨¨
    Ã  ¤«¨­                                          ³       ³ 0 ÃÙ
 2  Ã  § ¯¨á¨                                        ³       ÀÄÄÄÙ
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                                                ³
 20 ³ ‡ €  … ‡ …  ‚ ˆ  Ž ‚ €  Ž                  ³
    ³                                                ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³  ˆ ¬ ï                                         ³
 11 ³                                                ³
    ³   ® « ï                                       ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    Ã  ’¨¯ ¯®«ï ( C,N,L,M,F )                        ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    Ã  0                                             ³
    Ã  0 § à¥§¥à¢¨-                                  ³
 4  Ã  0 à®¢ ­®                                      ³
    Ã  0                                             ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    Ã  ¤«¨­  ¯®«ï (¢ª«îç ï ç¨á«® ¤¥áïâ¨ç­ëå ¯®§¨æ¨©) ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    Ã  ç¨á«® ¤¥áïâ¨ç­ëå à §àï¤®¢                     ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    Ã                                                ³
 14 Ã  ‡ €  … ‡ …  ‚ ˆ  Ž ‚ €  Ž                 ³
    Ã                                                ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³  â¥à¬¨­ «ì­ë© ¡ ©â ASCII 10                    ³
    ÆÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍµ
 §  ³ ¯à¨§­ ª ã¤ «¥­¨ï ASCII 42 (*), ­¥â ASCII 32 ( )³
    ³                  .  .   .                      ³
 ¯  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
 ¨  ³ ¯à¨§­ ª ã¤ «¥­¨ï ASCII 42 (*), ­¥â ASCII 32 ( )³
 á  ³                  .   .  .                      ³
 ¨  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
}

UNIT dbFile;
INTERFACE
uses Objects,xDos,Strings;
 CONST stOk=0;
       stBof=1;
       stEof=2;
       On=true; Off=false;
       stDelete:Char='*';
       stNormal:Char=' ';

 TYPE
      TFName=Array[0..10] of char;

      PField=^TField;
      TField=Record
       _Name:TFName;
       _Type:char;
       _Length:byte;
       _Dec:byte;
       _Ofs:word;
       _next:pointer;
      end;

      TFilter=Function(var TdbFile):boolean;

      PdbFile=^TdbFile;
      TdbFile=OBJECT(TxBufStream)
              Date:record
                   yy,mm,dd:byte
                   end;
              LenHeader:Word;
              RecCount:longint;
              RecLength:Word;
              Fields:PField;
              State:byte;
              DelCheck:Boolean;
              CurRec:Longint;
              Filter:TFilter;

       Constructor Init(FileName:FNameStr; SizeofBuf:word);
             { ®âªàë¢ ¥â ã¦¥ ª¥¬ â® á®§¤ ­­ãî „. FNameStr-¨¬ï, SizeOfBuf-à §¬¥à ¡ãä¥à  à¥ª®¬¥­¤ã¥âáï ­¥ ¬¥­¥¥ 4096 }
       Constructor Create(FileName:FNameStr; SizeofBuf:word; Pf:PField);
             { á®§¤ ¥â ¯ãáâãî „. FNameStr-¨¬ï, SizeOfBuf-à §¬¥à ¡ãä¥à , Pf-®¯¨á â¥«¨ áâàãªâãàë }
       procedure Append( var Rec ); Virtual;
             { ¤®¡ ¢«ï¥â Rec ¢ ª®­¥æ „ }
       procedure AppendBlank;
             { ¤®¡ ¢«ï¥â ¯ãáâãî § ¯¨áì ¢ „ (ªãç  ¯à®¡¥«®¢) }
       function Bof:Boolean; Virtual;
             { True - ¯®¯ëâª  ¢ëå®¤  §  ­ ç «® , False - ¢á¥ OK }
       procedure Delete;  Virtual;
             { à §ã¬¥¥âáï ã¤ «¥­¨¥ (ãáâ ­®¢ª  "*") }
             { Warning! ‚ á¢ï§¨ á â¥¬, çâ® ¯à®æ¥¤ãà  PACK ¯®ª  ­¥ à¥ «¨§®¢ ­  ! }
             { ! ä¨§¨ç¥áª¨ íâ¨ § ¯¨á¨ ¨§ „ ã¤ «¨âìáï ¯®ª  ­¥ ¬®£ãâ. Sorry ! }
       function Deleted:Boolean; Virtual;
             { True - â¥ªãé. § ¯¨áì ã¤ «¥­ , False - ­¥ ã¤ «¥­  }
       function Eof:Boolean; Virtual;
             { True - ¯®¯ëâª  ¢ëå®¤  §  ª®­¥æ , False - ¢á¥ OK }
       function Field(numField:byte):PField;
             { ¢®§¢à é ¥â ãª § â¥«ì ­  ®¯¨á â¥«ì ¯®«ï á ®¬¥à®¬ ¢ numField (1..N) }
       procedure Gather( var Rec ); Virtual;
             { § ¯¨áë¢ ¥â Rec ¢ â¥ªãéãî § ¯¨áì }
             { †¥« â¥«ì­® çâ®¡ë ¤«¨­  § ¯¨á¨ ¨ Rec á®¢¯ ¤ «¨,   â® ã ¢ á ¬®£ãâ ¢®§­¨ª­ãâì ­¥¯à¨ïâ­®áâ¨}
       procedure Go( numRec:LongInt ); Virtual;
             { ¯¥à¥¬¥é ¥¬áï ª § ¯¨á¨ á ­®¬¥à®¬ numRec (1..RecCount) }
       procedure GoBottom;
             { ¯¥à¥¬¥é ¥¬áï ¢ ª®­¥æ „ (¯àï¬® ­  RecCount) }
       procedure GoTop;
             { ¯¥à¥¬¥é ¥¬áï ¢ ­ ç «® „ (¯àï¬® ­  1) }
       procedure Insert(var Rec); Virtual;
             {… €Ž’€…’! ‚áâ ¢«ï¥â Rec ¯¥à¥¤ â¥ªãé¥© § ¯¨áìî}
       procedure Pack;
             {… €Ž’€…’! ”¨§¨ç¥áª¨ ã¤ «ï¥â § ¯¨á¨ ¯®¬¥ç¥­­ë¥ ­  ã¤ «¥­¨¥ "*" }
       procedure ReadFromField( var Rec; numField:byte );Virtual;
             { ç¨â ¥â ¢ Rec ¤ ­­ë¥ ¨§ ¯®«ï numField â¥ªãé¥© § ¯¨á¨ }
       function ReadStr(numField:byte):String;
             { ¢®§¢à é ¥â ª ª áâà®ªã ¤ ­­ë¥ ¨§ ¯®«ï numField â¥ªãé¥© § ¯¨á¨ }
       procedure RecAll;
             { ¢®ááâ ­ ¢«¨¢ ¥â â¥ªãéãî § ¯¨áì ¯®¬¥ç¥­­ãî ­  ã¤ «¥­¨¥ }
       function Recno:Longint;
             { ¢®§¢à é ¥â ¯®àï¤ª®¢ë© ­®¬¥à â¥ªãé¥© § ¯¨á¨ }
       procedure Scatter( var Rec );
             { ç¨â ¥â ¤ ­­ë¥ ¨§ â¥ªãéã¥© § ¯¨á¨ ¢ Rec }
             { †¥« â¥«ì­® çâ®¡ë ¤«¨­  § ¯¨á¨ ¨ Rec á®¢¯ ¤ «¨,   â® ã ¢ á ¬®£ãâ ¢®§­¨ª­ãâì ­¥¯à¨ïâ­®áâ¨}
       procedure SetDeleted(st:Boolean);
             { “áâ ­ ¢«¨¢ ¥â à¥¦¨¬ ¯à®å®¤  ¤«ï Skip ¯® ã¤ «¥­­ë¬ § ¯¨áï¬:
               On - ¨£­®à¨à®¢ âì § ¯¨á¨ ¯®¬¥ç¥­­ë¥ ­  ã¤ «¥­¨¥
               Off - ­¥ ¨£­®à¨à®¢ âì}
       procedure SetFilter(P:pointer);
             { ãáâ ­®¢ª  ä¨«ìâà , ä¨«ìâà ¤®«¦¥­ ¡ëâì ¤ «ì­¥© äã­ªæ¨¥© â¨¯  TFilter
               ¨ ¢®§¢à é âì True - ¥á«¨ â¥ªãé ï § ¯¨áì (¨«¨ á®áâ®ï­¨¥ á¨áâ¥¬ë ­  ¤ ­­ë© ¬®¬¥­â ¢à¥¬¥­¨)
               ¢ á ã¤®¢«¥â¢®àï¥â ¨ False - ¥á«¨ ­¥â }
       procedure Skip(Step:integer);
             { ¯¥à¥¬¥é¥­¨¥ ­  Step § ¯¨á¥© ¢¯¥à¥¤(>0) ¨«¨ ­ § ¤(<0) ¯® „. }
       procedure WriteStr(Str:String; numField:byte);
             { § ¯¨áë¢ ¥â áâà®ªã Str ¢ ¯®«¥ numField â¥ªãé¥© § ¯¨á¨ }
       procedure WriteToField( var Rec; numField:byte );Virtual;
             { § ¯¨áë¢ ¥â Rec ¢ ¯®«¥ numField â¥ªãé¥© § ¯¨á¨ }
       Destructor Done; Virtual;
             { § ªàë¢ ¥â „ ®¡­®¢«ïï ¥¥ ¯ à ¬¥âàë }
             end;

 function NewField(NameF:PChar; TypeF:char; LengthF:byte;
                   DecF:byte; nextF:PField):PField;
             { á®§¤ ¥â ®¯¨á â¥«ì ¯®«ï „ ¨ ¢®§¢à é ¥â ­  ­¥£® ãª § â¥«ì
             NameF - ¨¬ï ¯®«ï, ­¥ ¡®«¥¥ 11 á¨¬¢®«®¢;
             TypeF - â¨¯ ¯®«ï C-á¨¬¢®«ì­ë©, N-ç¨á«®¢®©, D-¤ â , L-«®£¨ç¥áª¨© ¨ â.¤.;
             LengthF - ¤«¨­  ¯®«ï 1..255;
             DecF - ç¨á«® ¤¥áïâ¨ç­ëå ¯®§¨æ¨© ( ¤«¨­  ¯®«ï - â®ç­®áâì - 1(â®çª ) );
             nextF - ãª § â¥«ì ­  á«¥¤ãîé¥¥ ¯®«¥ ¨«¨ nil ¥á«¨ ­¥â }
IMPLEMENTATION

 Constructor TdbFile.Init;
 var i:Word;
     Pf:PField;
     ofsInRecord:word;
 begin
   inherited Init(FileName,stOpen,SizeofBuf);
    if Status<>stOk then exit;
   seek(1);
   Read(Date,3);
   Read(RecCount,4);
   Read(LenHeader,2);
   Read(RecLength,2);
   i:=32;
   seek(i);
   ofsInRecord:=1;
   New(Fields);
   Pf:=Fields;
   while i < LenHeader do
    with Pf^ do
    begin
      Read(_Name,11);
      Read(_Type,1);
      Seek(i+16);
      Read(_Length,1);
      Read(_Dec,1);
      _Ofs:=ofsInRecord;
      ofsInRecord:=ofsInRecord + _Length;
      _next:=New(PField);
      Pf:=_next;
     i:=i+32;
     Seek(i);
    end;
   with Pf^ do
   begin
     Read(_Name,11);
     Read(_Type,1);
     Seek(i+16);
     Read(_Length,1);
     Read(_Dec,1);
     _Ofs:=ofsInRecord;
     _next:=nil;
   end;
    SetDeleted(off);
    Go(1);
    @Filter:=nil;
 end;

 Constructor TdbFile.Create(FileName:FNameStr; SizeofBuf:word; Pf:PField);
 var Temp:string;
     Count:word;
 Begin
 inherited Init(FileName, stCreate, SizeofBuf);
 Fields:=Pf;
 RecCount:=0;
 Count:=0; RecLength:=1;
 while Pf <> nil do
 begin
  Count:=Count+1;
  RecLength:=RecLength+Pf^._Length;
  Pf:=Pf^._next;
 end;
 LenHeader:=32+Count*32+1;
   Temp[1]:=#03;
   Date.yy:=GetYear-1900;
   Date.mm:=GetMonth;
   Date.dd:=GetDay;
 write(Temp[1],1);
 write(Date,3);
 write(RecCount,4);
 write(LenHeader,2);
 write(RecLength,2);
    FillChar(Temp,20,0);
 {(C) ILYJA pro. 1993y}
 write(Temp,20);
 Pf:=Fields; Count:=1;
 while Pf <> nil do
  with Pf^ do
  begin
   write(_Name,11);
   write(_Type,1);
   write(Temp,4);
   write(_Length,1);
   write(_Dec,1);
   write(Temp,14);
   _Ofs:=Count;
   Count:=Count+_Length;
   Pf:=_next;
  end;
 Temp[1]:=#10;
 write(Temp[1],1);
 Go(1);
 @Filter:=nil;
 SetDeleted(off);
 End;

 procedure TdbFile.Append( var Rec );
 Begin
 Go(RecCount+1);
 Write(Rec,RecLength);
 RecCount:=RecCount+1;
 Go(RecCount);
 End;

 procedure TdbFile.AppendBlank;
 var
  PTemp:pointer;
 Begin
 GetMem(PTemp,RecLength);
 FillChar(PTemp^, RecLength, 32);
 Append(PTemp^);
 FreeMem(PTemp,RecLength);
 end;

 function TdbFile.Bof:Boolean;
 Begin
 if (State=stBof) Or (CurRec<1) then Bof:=True
 else Bof:=False;
 End;

 procedure TDbFile.Delete;
 begin
 Write(stDelete,1);
 Seek(GetPos-1);
 end;

 function TdbFile.Deleted:Boolean;
 var ch:char;
 Begin
 Read(ch,1);
 if Ch=stNormal then Deleted:=False
 else Deleted:=True;
 Seek(GetPos-1);
 End;

 function TdbFile.Eof:Boolean;
 Begin
 if (State=stEof) Or (CurRec>RecCount) then Eof:=True
 else Eof:=False;
 End;

 function TdbFile.Field(numField:byte):PField;
 var Pf:PField;
 Begin
  Pf:=Fields;
  while numField > 1 do
  begin
   Pf:=Pf^._next;
   Dec(numField);
  end;
 Field:=Pf; {! ¢®§¬®¦­ë ®è¨¡ª¨ ¢ëå®¤  §  ¤¨ ¯ §®­ !}
 end;

 procedure TdbFile.Gather( var Rec );
 Begin
 if Not(Eof) then begin
                  Write(Rec,RecLength);
                  Go(CurRec);
                  end;
 end;

 procedure TdbFile.Go( numRec:LongInt );
 Begin
 if numRec > RecCount then
  begin
   CurRec:=RecCount+1;
   Seek(LenHeader+RecCount*RecLength);
   State:=stEof;
  end
 else if numRec<1 then
       begin
        CurRec:=1;
        Seek(LenHeader);
        State:=stBof;
       end
      else
       Begin
        State:=stOk;
        Seek(LenHeader+(numRec-1)*RecLength);
        CurRec:=numRec;
       End;
 End;

 procedure TdbFile.GoBottom;
 Begin
 CurRec:=RecCount+1;
 Skip(-1);
 end;

 procedure TdbFile.GoTop;
 Begin
 CurRec:=0;
 Skip(1);
 end;

 procedure TdbFile.Insert(var Rec);
 Begin
 End;

 procedure TdbFile.Pack;
 Begin
 End;

 procedure TdbFile.ReadFromField( var Rec; numField:byte);
 var n:Longint;
     Pf:PField;
 Begin
  n:=GetPos;
  Pf:=Field(numField);
  Seek(n+Pf^._ofs);
  Read(Rec,Pf^._Length);
  Seek(n);
 End;

 function TdbFile.ReadStr(numField:byte):String;
 var str:string;
 Begin
  ReadFromField(Str[1], numField);
  Str[0]:=Char(Field(numField)^._Length);
  ReadStr:=Str;
 End;

 procedure TDbFile.RecAll;
 begin
 Write(stNormal,1);
 Seek(GetPos-1);
 end;

 function TdbFile.Recno:Longint;
 Begin
 if CurRec=( (GetPos-LenHeader) div RecLength ) + 1 then Recno:=CurRec
                                                    else Halt(211);
 End;


 procedure TdbFile.SetDeleted(st:Boolean);
 Begin
 DelCheck:=st;
 end;

 procedure TdbFile.SetFilter(P:Pointer);
 Begin
 @Filter:=P;
 end;

 procedure TdbFile.Scatter( var Rec );
 Begin
 if Not(Eof) then begin
                  Read(Rec,RecLength);
                  Go(CurRec);
                  end;
 end;

 procedure TdbFile.Skip(Step:integer);
 Begin
 CurRec:=CurRec+step;
 Go(CurRec);
 While (State=stOk) And (((@Filter<>nil)and(Filter(Self)=false)) Or (DelCheck And Deleted)) do
  begin
  if step > 0 then CurRec:=CurRec+1
              else CurRec:=CurRec-1;
  Go(CurRec);
  end;
 End;

 procedure TdbFile.WriteStr(Str:String; numField:byte);
 Begin
  FillChar(str[length(str)+1], 255-length(str), 0);
  WriteToField(str[1],numField);
 End;

 procedure TdbFile.WriteToField( var Rec; numField:byte );
 var n:Longint;
     Pf:PField;
 Begin
  n:=GetPos;
  Pf:=Field(numField);
  Seek(n+Pf^._Ofs);
  Write(Rec,Pf^._Length);
  Seek(n);
 End;

 Destructor TdbFile.Done;
 var Pf:PField;
 begin
  while Fields <> nil do
  begin
    Pf:=Fields;
    Fields:=Fields^._next;
    Dispose(Pf);
  end;
  seek(1);
  Date.yy:=GetYear-1900;
  Date.mm:=GetMonth;
  Date.dd:=GetDay;
  write(Date,3);
  write(RecCount,4);
  write(LenHeader,2);
  write(RecLength,2);
 inherited Done;
 end;


 function NewField(NameF:PChar; TypeF:char; LengthF:byte;
                   DecF:byte; nextF:PField):PField;
 var P:PField;
 Begin
 New(P);
 FillChar(P^,SizeOf(TField),0);
 with P^ do Begin
            StrLCopy(_Name, NameF, 11);
            _Type:=TypeF;
            _Length:=LengthF;
            _Dec:=DecF;
            _next:=nextF;
            end;
 NewField:=P;
 End;

 End.
