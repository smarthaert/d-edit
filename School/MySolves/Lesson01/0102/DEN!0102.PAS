{ Явные глюки в решении !!!!!!!!!!!!!!!!!!!!!!!!!!!! }
(*
in.txt
4 
8
7
4
3
out.txt
9
1 2
2 1
2 3
3 1
3 4
4 1
2 4
4 1
1 4
Must be:
8
1 2
2 3
3 2
2 4
4 1
4 1
1 3
3 4
*)
{ Программа для определение оптимальной последовательности вычитаний }
{ в алгоритме вычисления НОД (Наибольшего общего делителя) набора чисел }
Var
  N : LongInt; { Количество чисел в наборе. Максимум - 100 чисел }
  A : Array [1..100] of LongInt; { Массив для хранения этих чисел }
  Min : LongInt; { Минимальное количество шагов }
  P : Array [1..100,1..2] of LongInt; { Текущее решение }
  PM : Array [1..100,1..2] of LongInt; { Наилучшее решение }

{ Рекурсивная процедура перебора дерева вариантов выбора пар для вычитания }
Procedure Rec( K:Word ); { K - Текущее количество шагов }
  Var Cnt,I,J:Integer;
  Begin
    If K >= Min then Exit; { Отсекаем лишние ветки перебора }
   { Подсчитываем количество ненулевых элементов }
    Cnt:=0; For I:=1 to N do If A[I]<>0 then Inc(Cnt);
   { Если очередное решение найдено, запоминаем его }
    If Cnt = 1 then
      Begin
        For I:=1 to (K-1) do { Запоминаем решение }
          For J:=1 to 2 do
            PM[I,J]:=P[I,J];
        Min:=K-1;
        Exit;
      End;
   { Новый шаг перебора }
    For I:=1 to N do
      For J:=1 to N do
        If ((A[I] >= A[J]) And (I<>J) And (A[J]<>0)) then
          Begin
            P[K,1]:=I; { Запоминаем уменьшаемое }
            P[K,2]:=J; { Запоминаем вычитаемое }
            A[I]:=A[I]-A[J]; { Вычитаем из уменьшаемого вычитаемое }
            Rec(K+1); { Новый шаг рекурсии }
            A[I]:=A[I]+A[J]; { Обратно добавляем вычитаемое }
          End;
  End;

{ Основная программа }
Var I:LongInt;
Begin
  Read(N); { Считываем их входного потока количество чисел в наборе }
  For I:=1 to N do Read(A[I]); { Считываем собственно числа набора }
  Min:=MaxLongInt; { Сначала минимальное количество шагов как можно больше }
  Rec(1); { Перебираем дерево вариантов и находим оптимальный }
  Writeln(Min); { Выводим количество шагов (пар для вычитания) }
  For I:=1 to (Min) do { Выводим последовательность шагов }
    Writeln(PM[I,1],' ',PM[I,2]);
End.